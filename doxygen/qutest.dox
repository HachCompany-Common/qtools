/*! @page qutest QUTest&trade; Unit Testing Harness

@image html  qutest_banner.jpg
@image latex qutest_banner.jpg width=6.5in

@subpage qutest_use "&nbsp;"
@subpage qutest_conc "&nbsp;"
@subpage qutest_tut "&nbsp;"
@subpage qutest_fixture "&nbsp;"
@subpage qutest_script "&nbsp;"

@section qutest_about About QUTest&trade;
<strong>QUTest&trade;</strong> (pronounced "cutest") is a **unit testing harness** (a.k.a. *unit testing framework*), which is specifically designed for deeply embedded systems, but also supports unit testing of embedded code on host computers ("dual targeting"). QUTest&trade; is the fundamental tooling for <a href="https://en.wikipedia.org/wiki/Test-driven_development" target="_blank" class="extern"><strong>Test-Driven Development (TDD)</strong></a> of <a href="https://www.state-machine.com/products/#QP" target="_blank" class="extern">QP/C/C++ applications</a>, which is a highly recommended best-practice.

@note
Even though QUTest&trade; has been primarily designed for testing of <a href="https://www.state-machine.com/doc/concepts#Event-Driven" target="_blank" class="extern">event-driven systems</a>, it can also be used to test **any embedded C or C++ code**. To demonstrate this capability, QUTest&trade; comes with a few examples from the conventional <a href="http://www.throwtheswitch.org/unity" target="_blank" class="extern">Unity testing framework</a>, which among others demonstrates such techniques as using <a href="https://martinfowler.com/bliki/TestDouble.html" target="_blank" class="extern">test doubles</a> and <a href="https://en.wikipedia.org/wiki/Mock_object" target="_blank" class="extern">mocks</a> with QUTest&trade;.


@subsection qutest_how How does it work?
In a nutshell, working with QUTest&trade; is similar to "debugging with printf" (or `sprintf` or similar), where you instrument the code to output information about its execution. You then run the code with a controlled set of inputs, and examine the produced output from the `printf`s to determine whether the code under test operates correctly. The main differences from using `printf`s are: (1) the much more efficient @ref qpspy "QP/Spy" output mechanism is used instead and (2) both generating the inputs and checking of the test outputs are **automated**.

The process of testing embedded code with QUTest&trade; involves the following components:

-# The **Target**, which runs an instrumented @ref qutest_fixture "test fixture" code, whose job is to exercise your <b>C</b>ode <b>U</b>nder <b>T</b>est (<b>CUT</b>). Please note that a @ref qutest_fixture "test fixture" only exercises the CUT  and reports the results to the host using @ref qpspy "QP/Spy", but the @ref qutest_fixture "test fixture" does **not** check if the CUT operates "correctly".<br>
@note Of course, the @ref qutest_fixture "test fixture" is written in the same programming language as the CUT (C or C++) and it links statically with the CUT. Several examples of *test fixtures* are explained in the @ref qutest_tut "QUTest Tutorial". The details of *test fixtures* are described in @ref qutest_fixture "QUTest Fixture Reference".

-# The @ref qspy "QSPY" "back-end" application running on the host, which receives the tracing data from the Target and also opens a communication channel for the QUTest "front-end".

-# The **QUTest** "front-end" also running on the host that executes @ref qutest_script "test scripts". The *test scripts* (written in Python) drive the tests and check the QSPY output against the expectations ("test-assertions").<br>
@note
Several examples of *test scripts* are explained in the @ref qutest_tut "QUTest Tutorial".  The details of *test scripts* are described in @ref qutest_script "QUTest Script Reference".

<br>
![Communication between Target, QSPY, and QUTest](qutest_targ.gif)


@remark
The separation between CUT execution and checking the test results has many benefits. One of the most important ones is that CUT execution (@ref qutest_fixture "test fixture") and checking the results (@ref qutest_script "test script") can be done in *different programming languages*. To this end QUTest&trade; provides support for writing the @ref qutest_script "test scripts in Python".
<br>
@image html  logo_python3.png
@image latex logo_python3.png width=5.0in


The general QUTest&trade; structure just described corresponds to running tests on an embedded Target. But QUTest&trade; can also execute tests on the **host computer**. In that case (shown in the figure below), the *@ref qutest_fixture "test fixture"* is a host executable that communicates with the @ref qspy_command "QSPY host application" via a TCP/IP socket. In this case all QUTest&trade; components execute on the host computer.

![QUTest with Host Executable](qutest_host.gif)


@remark
To work effectively with QUTest&trade;, you need to understand **how much output to expect from any given input**. Additionally, you need to understand how QUTest ensures that for every input to the @ref qutest_fixture "test fixture", the generated QSPY output matches all test expectations and that there are no extra expectations or missing expectations after every command from the @ref qutest_script "test script". These subjects are explained in the section @ref qutest_conc "Run-to-Completion Processing".


@subsection qutest_special What's Special about QUTest&trade;?
Unlike other existing unit testing harnesses for embedded systems (e.g., <a href="http://www.throwtheswitch.org/white-papers/unity-intro.html" target="_blank" class="extern">Unity</a> or <a href="http://cpputest.github.io/" target="_blank" class="extern">CppUTest</a>) QUTest&trade; is **not based on** <a href="https://en.wikipedia.org/wiki/XUnit" target="_blank" class="extern"><strong>xUnit</strong></a>, which was originally designed to run tests on host computers. Instead, QUTest&trade; is geared towards unit testing of **deeply embedded systems**. Here is a list of QUTest&trade; unique features, specifically designed for this purpose:

- QUTest&trade; separates *execution* of the CUT (Code Under Test) from *checking* of the "test assertions". The embedded target is concerned only with running a @ref qutest_fixture "test fixture" that exercises the CUT and produces the QP/Spy&trade; trace, but it does *not* check the "test assertions". Checking the "test assertions" against the expectations is performed on the host computer by means of @ref qutest_script "test scripts".

- The QUTest&trade; approach is more **intuitive for embedded developers**, because it is conceptually like automated "debugging by printf" that most embedded developers use extensively. As it turns out, this approach also simplifies the development of all sorts of <a href="https://martinfowler.com/bliki/TestDouble.html" target="_blank" class="extern">test doubles</a>, including <a href="https://en.wikipedia.org/wiki/Mock_object" target="_blank" class="extern">mocks</a>, *without breaking encapsulation* of the CUT.

- QUTest&trade; is a unique test harness on the embedded market that supports **scripting**. QUTest @ref qutest_script "test scripts" run on the Host, which skips compiling and uploading the code to the Target and thus shortens the TDD micro-cycle.

@note
QUTest&trade; supports *test scripts* written in [Python](https://www.python.org) (3.3+).


- QUTest&trade; supports **resetting the Target** for each individual test, if needed. This goes far beyond providing test `setup()` and `teardown()` functions that other test fixtures offer (and of course QUTest supports as well). Clean reset of the Target avoids erroneous tests that implicitly rely on side effects from previously executed code. This is particularly important for embedded systems and for state machines, so that each test can start from a known reset condition.

- QUTest&trade; supports **testing Design by Contract** (assertions in C or C++, not to be confused with "test assertions") in the CUT. This is a carefully designed, unique feature of QUTest not available in other test harnesses. A successful test of DbC might actually mean breaking an assertion in the Target code.

- QUTest&trade; @ref qutest_fixture "test fixtures" that run on the Target **do not require dynamic memory** allocation (`malloc()/free()` in C or `new/delete` in C++). This means that you don't need to commit any of your precious embedded RAM to the heap (you can set the heap size to zero) and you don't need to link the heap management code. Avoiding dynamic memory allocation is one of the best practices of real-time embedded programming, which you don't need to compromise to run QUTest.

- QUTest&trade; @ref qutest_fixture "test fixtures" that run on the Target **do not require non-local jumps** (`setjmp()()/longjmp()` in C or `throw/catch` in C++), which are needed by other test harnesses to discontinue failing tests. QUTest&trade; *test fixtures* do not need to discontinue failing tests, because they don't check "testing assertions", so a *test fixture does* not "know" if it is failing or passing. Should a test fixture crash on the Target, it simply waits for the target reset commanded by a @ref qutest_script "test script".

- QUTest&trade; @ref qutest_fixture "test fixtures" can be based on the actual **application code**. For example, you can reuse the same `main()` function in a @ref qutest_fixture "test fixture" and in your final application. This means that you can either grow your @ref qutest_fixture "test fixture" into a final application through TDD, or you can more easily add unit tests to an existing application.

@note
Even though QUTest&trade; is particularly suitable for running tests on deeply embedded targets, it also fully supports running *the same* tests on your **host computer** (Windows, Linux, and MacOS are supported). In fact, running the tests as much as possible on the host and thus avoiding the target-hardware bottleneck is the highly recommended best-practice of embedded TDD.  QUTest&trade; supports **fully-automated** unit testing, both on the embedded target and on the host computer.


@nav_next{qutest_use}
*/

/*###########################################################################*/
/*! @page qutest_use Installation &amp; Use
@nav{qutest,qutest_conc}

In order to run tests in the QUTest test system, you need the following three components:

1. The @ref qutest_fixture "test fixture" running on a remote target (or the host computer)
2. The @ref qspy "QSPY host application" running and connected to the target
3. The @ref qutest_script "qutest.py script runner" and some test scripts

This section describes how to install and use the "qutest.py script runner" component.

@section qutest_inst Installation
The "qutest.py script runner" can be used standalone, without installation in your Python system (see  @ref qutest_exa below).

@note
The <span class="img file_py">qutest.py</span> script is included in the @ref qtools_about "QTools&trade; collection". Also, the @ref qtools_win "QTools&trade; collection for Windows" already includes Python (3.8), so you don't need to install anything extra.


Alternatively, you can use **your own Python** installation, into which you can install the latest QUTest&trade; with `pip` from the [<b>PyPi index</b>](https://pypi.org/project/qutest/) by executing the following command:

@verbatim
pip install qutest
@endverbatim

If you are using QUTest&trade; as a standalone Python script, you invoke it as follows:

@verbatim
python3 <path-to-qutest-script>/qutest.py <command-line-options>
@endverbatim

Alternatively, if you've installed `qutest.py` with `pip`, you invoke it as follows:

@verbatim
qutest <command-line-options>
@endverbatim


@section qutest_command Command-line Options
The Python test scripts are executed by the QUTest test script runner `qutest.py` (located in `qtools/qutest/` folder), with the following usage:

@attention
The `qutest.py` script runner command-line options have been expanded and changed at @ref qtools_7_2_0 "version 7.2.0". Unfortunately, it was not possible to preserve the backwards compatibility with the earlier versions.

@verbatim
usage: python qutest.py [-h] [-v] [-e [EXE]] [-q [QSPY]] [-l [LOG]] [-o [OPT]] [scripts ...]

QUTest test script runner

positional arguments:
  scripts               List (comma-separated) of test scripts to run

options:
  -h, --help            show this help message and exit
  -v, --version         Display QUTest version
  -e [EXE], --exe [EXE]
                        Optional host executable or debug/DEBUG
  -q [QSPY], --qspy [QSPY]
                        optional qspy host, [:ud_port][:tcp_port]
  -l [LOG], --log [LOG]
                        Optional log directory (might not exist yet)
  -o [OPT], --opt [OPT]
                        xciob: x:exit-on-fail,i:inter,c:qspy-clear,o:qspy-save-txt,b:qspy-save-bin

More info: https://www.state-machine.com/qtools/qutest.html
@endverbatim

where:<br>

@param [scripts] optional specification of the Python test scripts to run.
                 If not specified, `qutest.py` will try to run all *.py files
                 in the current directory as test scripts.

@param -e[exe]   optional specification of the host executable to
                 launch for testing embedded code on the host computer.
                 If `exe` is **not** specified a remote (embedded) target is assumed.
                 The special value `debug` or `DEBUG` means that `qutest.py`
                 will start in the **debug mode**, in which it will NOT launch
                 the host executable and it will wait for the Target reset
                 and other responses from the Target.

@param -q[host][:ud_port][:tcp_port] optional host-name/IP-address:udp_port:tcp_port
                 for the machine running the QSpy utility. If not specified,
                 the default is `localhost:7701:6601`.

@param -l[log]   Optional directory for output of the log file
                 (directory will be created if it does not exist yet).

@param -o[opt]   options for the QUTest script runner to perform the
                 following actions:<br>
                 x : exit on first failed test<br>
                 i : interactive mode<br>
                 c : clear the QSPY screen just after attaching<br>
                 o : save the QSPY text output to a file (in the QSPY launch directory)<br>
                 b : save the QSPY binary output to a file (in the QSPY launch directory)

@note
For reliable operation it is recommended to apply the short options *without* a space between the option and the parameter (e.g., `-q192.168.1.100`, `-oci`).


@section qutest_exa Examples
<img style="float:left; clear:left; margin-right:10px" src="img/logo_win48.png">
@subsection qutest_exa_win Windows Hosts
<div style="clear:both"></div>

@verbatim
[1] python3 %QTOOLS%\qutest\qutest.py
[2] python3 %QTOOLS%\qutest\qutest.py -- test_mpu.py
[3] python3 %QTOOLS%\qutest\qutest.py -ebuild/test_dpp.exe
[4] python3 %QTOOLS%\qutest\qutest.py -ebuild/test_dpp.exe -q192.168.1.100 -l../log -oco
[5] qutest -qlocalhost:7702 -oxc --  test_qk.py,test_mpu.py
[6] python3 %QTOOLS%\qutest\qutest.py -eDEBUG -- test_mpu.py
@endverbatim

`[1]` runs all test scripts (`*.py`) in the current directory on a remote target connected to QSPU host utility.

`[2]` runs the test script `test_mpu.py` in the current directory on a remote target connected to QSPU host utility.

`[3]` runs all test scripts (`*.py`) in the current directory and uses the host executable `build/test_dpp.exe` (test fixture).

`[4]` runs all test scripts (`*.py`) in the current directory, uses the host executable `build/test_dpp.exe` (test fixture), and connects to QSPY running on a machine with IP address `192.168.1.100`. Also produces QUTest log (-l) in the directory `../log`. Also clears the QUTest screen before the run (-oc) and causes QSPY to save the text output to a file (-oo)

`[5]` runs "qutest" (**installed with pip**) to execute the test scripts `test_qk.py,test_mpu.py` in the current directory, and connects to QSPY at UDP-host:port `localhost:7701`.

`[6]` runs "qutest" in the DEBUG mode to execute the test script `test_mpu.py` in the current directory.

<br>
<img style="float:left; clear:left; margin-right:10px" src="img/logo_linux48.png">
<img style="float:left; margin-right:10px" src="img/logo_macos48.png">
@subsection qutest_exa_posiz Linux/macOS Hosts
<div style="clear:both"></div>

@verbatim
[1] python3 $(QTOOLS)/qutest/qutest.py
[2] python3 $(QTOOLS)/qutest/qutest.py -- test_mpu.py
[3] python3 $(QTOOLS)/qutest/qutest.py -ebuild/test_dpp
[4] python3 $(QTOOLS)/qutest/qutest.py -ebuild/test_dpp -q192.168.1.100 -l../log -oco
[5] qutest -qlocalhost:7702 -oxc --  test_qk.py,test_mpu.py
[6] python3 $(QTOOLS)/qutest/qutest.py -eDEBUG -- test_mpu.py
@endverbatim

`[1]` runs all test scripts (`*.py`) in the current directory on a remote target connected to QSPU host utility.

`[2]` runs the test script `test_mpu.py` in the current directory on a remote target connected to QSPU host utility.

`[3]` runs all test scripts (`*.py`) in the current directory and uses the host executable `build/test_dpp` (test fixture).

`[4]` runs all test scripts (`*.py`) in the current directory, uses the host executable `build/test_dpp` (test fixture), and connects to QSPY running on a machine with IP address `192.168.1.100`. Also produces QUTest log (-l) in the directory `../log`. Also clears the QUTest screen before the run (-oc) and causes QSPY to save the text output to a file (-oo)

`[5]` runs "qutest" (**installed with pip**) to execute the test scripts `test_qk.py,test_mpu.py` in the current directory, and connects to QSPY at UDP-host:port `localhost:7701`.

`[6]` runs "qutest" in the DEBUG mode to execute the test script `test_mpu.py` in the current directory.


@section qutest_inter Interactive Mode
Similar to the Python interpreter itself, the `qutest.py` test runner has two basic modes: script (default) and interactive. In the default script mode, `qutest.py` runs the provided @ref qutest_script "test scripts" and exits. In the **interactive mode** the reads and executes commands *interactively* @ref from the terminal input. The interactive mode is activated by providing the `-oi` @ref qutest_command "command-line option". Interactive mode is a good way to play around and try the system's response to various commands. Also, interactive mode can be used to provide stimuli for debugging the @ref qutest_fixture "test fixture".

Once activated, the interactive mode works as follows:

- If any test scripts are provided, after each test group (test script) the test runner enters an interactive session, where the user can manually enter any supported test commands. These commands are executed in the context of the *last test in the group*. Tt is also possible to start a new test interactively (by providing the @ref qutest_dsl::test() "test()" command). In that case, the interactively entered commands will be executed in the context of the new test.

- If no test scripts are provided, the test runner enters an interactive session immediately. In that case, the user must provide the @ref qutest_dsl::test() "test()" command manually (perhaps after defining the @ref qutest_dsl-preamble "test callbacks").

In either case, the interactive mode is shown by the presence of the `>>> ` command prompt. During an interactive session the output produced by the text fixture is displayed on the screen and **not** checked against any expectations. In fact, the @ref qutest_dsl::expect() "expect()" command itself makes no sense in the interactive mode. Also, all tests that are interactive are considered "SIKPPED" and are not evaluated as "PASS" or "FAIL".

@note
You can use the up- and down-arrow keys to navigate through the list of previous commands. You end the interactive session by providing an "empty" command, that is by pressing the `<Enter>` key right at the `>>> ` command prompt

Here is an example of an interactive session with test scripts provided. (Note the annotations added after the `//` comments).

@verbatim
C:\qp\qpc\examples\qutest\qhsmtst\test>make OPT=i   // <--- NOTE OPT=i

python3 C:\qp\qtools/qutest/qutest.py -ebuild/test_qhsmtst.exe -q -l -oci --

QUTest unit testing front-end 7.2.1 running on Python 3.10.1
Copyright (c) 2005-2022 Quantum Leaps, www.state-machine.com
Attaching to QSpy (localhost:7701) ... OK

Run ID    : 230111_174610
Target    : build/test_qhsmtst.exe

==================================[Group  1]==================================
test_qhsm-funct.py
[ 1]--------------------------------------------------------------------------
QHsmTst_init
                                                             [ PASS (  0.1s) ]
[ 2]^-------------------------------------------------------------------------
QHsmTst dispatch
>>> dispatch('A_SIG')      // <--- interactive command
0000000127 BSP_DISPLAY s1-A;
0000000128 BSP_DISPLAY s11-EXIT;
0000000129 BSP_DISPLAY s1-EXIT;
0000000130 BSP_DISPLAY s1-ENTRY;
0000000131 BSP_DISPLAY s1-INIT;
0000000132 BSP_DISPLAY s11-ENTRY;
0000000133 Trg-Done QS_RX_EVENT
>>> dispatch('B_SIG')      // <--- interactive command
0000000134 BSP_DISPLAY s1-B;
0000000135 BSP_DISPLAY s11-EXIT;
0000000136 BSP_DISPLAY s11-ENTRY;
0000000137 Trg-Done QS_RX_EVENT
>>>                        // <--- end of interactive session
                          interactive test shows as "skipped" ---> [ SKIPPED ]

==================================[Group  2]==================================
test_qhsm-struct.py
[ 3]--------------------------------------------------------------------------
QHsmTst init
                                                             [ PASS (  0.1s) ]
[ 4]^-------------------------------------------------------------------------
QHsmTst dispatch
>>>                        // <--- end of interactive session
                                                                   [ SKIPPED ]

==================================[ SUMMARY ]=================================

Target ID : 230111_170758 (QP-Ver=721)
Log file  :
Groups    : 2
Tests     : 4
Skipped   : 2 [ 2 4 ]
Failed    : 0

==============================[  OK  ( 20.1s) ]===============================
@endverbatim


@section qutest_log Generating Test Logs
As required for safety certification, the `qutest.py` test runner can generate permanent records of the runs by producing **log files**. This feature is enabled by the `-l<log-dir>` command-line option.

@remark
The various make-files supplied in QP/C and QP/C++ allow you to supply the command-line options for saving QUTest logs (by defining the `LOG=` symbol while invoking `make`), for example:
@verbatim
[1] make LOG=.
[2] make LOG=../log
[3] make LOG=c:/cert/logs
@endverbatim
`[1]` generates QUTest log file in the current directory (`.`)

`[2]` generates QUTest log file in the `../log` directory (relative to the current directory)

`[3]` generates QUTest log file in the absolute directory `c:/cert/logs`

The following following listing shows the generated log file:

The following screen shot shows the qutest.py screen output in which a log file has been produced (with the `-l.` command-line option):

@image html  qutest-out.png
@image latex qutest-out.png with=4.0in

And the following listing shows the generated log file:

@verbatim
Run ID    : 221221_161550
Target    : build/test_qutest.exe

===================================[group]====================================
test_assert.py

This test group contains tests that intenionally FAIL,
to exercise failure modes of the QUTest system.

[ 1]--------------------------------------------------------------------------
Expected assertion
                                                             [ PASS (  0.1s) ]
[ 2]--------------------------------------------------------------------------
Unexpected assertion (should FAIL!)
  @test_assert.py:22
exp: "0000000002 COMMAND CMD_A 0"
got: "0000000002 =ASSERT= Mod=test_qutest,Loc=100"
! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ![ FAIL (  0.2s) ]
[ 3]--------------------------------------------------------------------------
Simple passing test
                                                             [ PASS (  0.1s) ]
[ 4]--------------------------------------------------------------------------
Wrong assertion expectation (should FAIL!)
  @test_assert.py:32
exp: "0000000002 =ASSERT= Mod=test_qutest,Loc=200"
got: "0000000002 =ASSERT= Mod=test_qutest,Loc=100"
! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ![ FAIL (  1.1s) ]
[ 5]--------------------------------------------------------------------------
Simple passing test
                                                             [ PASS (  0.1s) ]

=================================[ SUMMARY ]==================================

Target ID : 221221_161031 (QP-Ver=720)
Log file  : ./qutest221221_161550.txt
Groups    : 1
Tests     : 5
Skipped   : 0
FAILED    : 2 [ 2 4 ]

==============================[ FAIL (  2.7s) ]===============================
@endverbatim


@section qutest_qspy_log Generating QSPY Logs
Additionally, it is also possible to generate logs files from the QSPY output. This feature is enabled by the `-oo` and `-ob` command-line options.

- the option `-oo` saves the QSPY text output generated during the qutest.py run. QSPY saves the output in the directory from which it was launched.

- the option `-ob` saves the QSPY raw binary output received from the test fixture during the qutest.py run. QSPY saves the output in the directory from which it was launched.

@remark
The various make-files supplied in QP/C and QP/C++ allow you to supply the command-line options for saving QSPY logs (by defining the `OPT=` symbol while invoking `make`), for example:
@verbatim
[1] make OPT=o
[2] make OPT=b
[3] make OPT=ob
@endverbatim
`[1]` generates QSPY text output (in the QSPY launch directory)<br>
`[2]` generates QSPY binary output (in the QSPY launch directory)<br>
`[3]` generates both QSPY text and binary outputs (in the QSPY launch directory)

@nav{qutest,qutest_conc}
*/

/*###########################################################################*/
/*! @page qutest_conc QUTest Concepts
@nav{qutest_use,qutest_tut}

@section qutest_rtc Run-to-Completion Processing
The central concept applied in QUTest is **Run-to-Completion (RTC)** processing, both in the @ref qutest_fixture "test fixture" (Target) and in the @ref qutest_script "test script" (Host). RTC processing means that the code progresses in discrete, uninterruptible steps and that new inputs (commands) are recognized only *after* the current RTC step completes.

@attention
RTC Processing is the key to understanding **how much output to expect from any given input** as well as **when a given input will be processed**.


Of course, it is not a coincidence that the RTC processing of QUTest exactly matches the RTC processing in event-driven systems of state machines. And the good news here is that for all interactions with state machines, the RTC output generated by a @ref qutest_fixture "test fixture" will correspond exactly to the RTC step in the state machine.

However, a bit more tricky parts are the system reset, test initialization, and general processing of @ref qutest_dsl-commands "commands" issued by @ref qutest_script "test scripts". The following sections explain these parts by means of annotated sequence diagrams.

@remark
For simplicity, the sequence diagrams in this section omit the QSPY intermediary from the communication between a @ref qutest_fixture "test fixture" (Target) and a @ref qutest_script "test script". It is understood that every command from the @ref qutest_script "test script" goes to QSPY first and then is forwarded to the Target, and that every output from the Target goes through QSPY to reach the @ref qutest_script "test script".


@section qutest_reset Target Reset
Most individual tests in a @ref qutest_script "test script" start with a clean **target reset**. The following sequence diagram shows the details of this process. The explanation section following the diagram clarifies the interesting points (labeled with `[xx]`). :

![Target reset](qutest_reset.gif)


`[0]` A @ref qutest_script "test script" executes the @ref qutest_dsl::test() "test()" command.

`[1]` By default, each test starts with calling an internal function `reset()` to reset the Target. This `reset()` function sends the ::QS_RX_RESET request to the @ref qutest_fixture "test fixture". After this, the @ref qutest_script "test script" enters a wait state in which it waits for ::QS_TARGET_INFO reply from the Target.
<br>
The Target reset can be suppressed by the `NORESET` option given in the @ref qutest_dsl::test() "test()" command, which is illustrated in the @ref qutest_noreset "NORESET Tests" sequence diagram. Please note, however, that the first test in a @ref qutest_script "test script" (test group) and any test immediately following an "assertion-test" **must** cleanly reset the Target (therefore it cannot use the `NORESET` option).

`[2]` The @ref qutest_fixture "test fixture" processes the ::QS_RX_RESET request immediately by calling the QS_onReset() callback inside the Target.
<br>
Embedded Targets reboot automatically after resetting. In case of a **host executable**, however, QUTest&trade; (qutest.py) launches it again.<br>

`[3]` The Target starts executing the @ref qutest_fixture "test fixture" code from the beginning. After QS gets initialized (QS_INIT()), the @ref qutest_fixture "test fixture" sends the ::QS_TARGET_INFO reply to the @ref qutest_script "test script".

`[4]` Upon reception of the awaited ::QS_TARGET_INFO reply, the @ref qutest_script "test script" attempts to execute the @ref qutest_dsl::on_reset() "on_reset()" procedure. If @ref qutest_dsl::on_reset() "on_reset()" is defined in the script, it runs at this time. (This scenario assumes that @ref qutest_dsl::on_reset() "on_reset()" is defined and runs until step `[8]`).

`[5]` A @ref qutest_fixture "test fixture" continues the initialization RTC step and typically produces some @ref qs_dict "QS dictionaries".
<br>
The @ref qs_dict "QS dictionaries" are consumed by QSPY and are **not** forwarded to the @ref qutest_script "test script".

`[6]` The @ref qutest_fixture "test fixture" might also produce some output that **is** forwarded to the @ref qutest_script "test script".

`[7]` Any such output needs to be explicitly expected by the @ref qutest_script "test script". The @ref qutest_dsl::on_reset() "on_reset()" procedure is the ideal place to handle such output.
<br>
The main purpose of the @ref qutest_dsl::on_reset() "on_reset()"` procedure is to consume any output generated during the reset RTC step as well as to perform any setup that should follow the Target reset. In principle, instead of coding @ref qutest_dsl::on_reset() "on_reset()", you could place all this code directly at every test, but this would be repetitious. Defining @ref qutest_dsl::on_reset() "on_reset()" allows you to avoid such repetitions.

`[8]` The @ref qutest_dsl::on_reset() "on_reset()" procedure ends and the @ref qutest_script "test script" sends ::QS_RX_TEST_SETUP to the Target.

`[9]` ::QS_RX_TEST_SETUP typically arrives while the @ref qutest_fixture "test fixture" still runs the initialization RTC. Therefore, ::QS_RX_TEST_SETUP is **not** processed immediately and its processing is delayed until the end of the current RTC step.

`[10]` A @ref qutest_fixture "test fixture" continues the initialization RTC step and might still produce some @ref qs_dict "QS dictionaries".

`[11]` Finally, the @ref qutest_fixture "test fixture" completes the initialization RTC by calling `QF_run()`. `QF_run()` runs an event loop, in which it processes commands that have accumulated from the @ref qutest_script "test script".

`[12]` The first such command is ::QS_RX_TEST_SETUP, which has been waiting in the input buffer.

`[13]` The acknowledgment for the ::QS_RX_TEST_SETUP is sent back to the @ref qutest_script "test script".

`[14]` Upon reception of "Trg-Ack QS_RX_TEST_SETUP", the @ref qutest_script "test script" attempts to execute the @ref qutest_dsl::on_setup() "on_setup()" procedure. If @ref qutest_dsl::on_setup() "on_setup()" is defined in the script, it runs at this time.
<br>
The main purpose of the @ref qutest_dsl::on_setup() "on_setup()" procedure is to consume any output generated from the QS_onTestSetup() callback in the @ref qutest_fixture "test fixture" invoked in the next step [15]. Note also the QS_onTestSetup() runs in all tests, including @ref qutest_noreset "NORESET tests".

`[15]` The @ref qutest_fixture "test fixture" calls the QS_onTestSetup() callback function in the Target.

`[16]` The @ref qutest_script "test script" proceeds with commands defined after the @ref qutest_dsl::test() "test()" command. Processing of these commands is explained in sections @ref qutest_simple and @ref qutest_complex.


@section qutest_pause Pausing the Reset
As explained in the previous section, the initialization RTC step in the @ref qutest_fixture "test fixture" extends throughout `main()`, from the beginning till the final call to `QF_run()`. The @ref qutest_fixture "test fixture" is unable to process any commands from the @ref qutest_script "test script" until the end of this long RTC step, which can limit the flexibility of the @ref qutest_fixture "test fixture".

For example, consider the @ref qutest_fixture "test fixture" in the DPP example for QUTest (directory <span class="img folder">`qpc/examples/qutest/dpp/test`</span>). This @ref qutest_fixture "test fixture" reuses the `main()` function from the actual DPP application, which starts multiple active objects. To enable unit testing of a specific single active object, it would be very convenient if the @ref qutest_script "test script" could set up the @ref qs_local "QS Local Filter" for the chosen active object component. Such a local filter would then select the output, such as initialization from a given AO. But the problem is that such a local filter requires the @ref qs_dict "QS object dictionary" to be already transmitted to QSPY. On the other hand, the local filter needs to take effect before the AOs are started. In other words, the initialization RTC step needs to be split into shorter pieces, right after sending the dictionaries, but before starting active objects.

For such situations, QUTest provides the QS_TEST_PAUSE() macro, which pauses the execution of an RTC step and enters an event loop within the @ref qutest_fixture "test fixture". This, in turn, allows the @ref qutest_fixture "test fixture" to process any commands from the @ref qutest_script "test script", before the RTC continues to completion (or to another QS_TEST_PAUSE(), if needed).

The following @ref qutest_fixture "test fixture" code illustrates the use of the QS_TEST_PAUSE() macro:

@code
     int main(int argc, char *argv[]) {
         static QEvt const *tableQueueSto[N_PHILO];
         static QEvt const *philoQueueSto[N_PHILO][N_PHILO];
         ~ ~ ~

         QF_init();    /* initialize the framework and the underlying RT kernel */
         BSP_init(argc, argv); /* NOTE: calls QS_INIT() */

         /* object dictionaries... */
         QS_OBJ_DICTIONARY(AO_Table);
         QS_OBJ_DICTIONARY(AO_Philo[0]);
         QS_OBJ_DICTIONARY(AO_Philo[1]);
         QS_OBJ_DICTIONARY(AO_Philo[2]);
         ~ ~ ~

         /* pause execution of the test and wait for the test script to continue */
 [1]     QS_TEST_PAUSE();

         /* initialize publish-subscribe... */
         QF_psInit(subscrSto, Q_DIM(subscrSto));

         /* initialize event pools... */
         QF_poolInit(smlPoolSto, sizeof(smlPoolSto), sizeof(smlPoolSto[0]));

         /* start the active objects... */
         Philo_ctor(); /* instantiate all Philosopher active objects */
         for (n = 0U; n < N_PHILO; ++n) {
             QACTIVE_START(AO_Philo[n],      /* AO to start */
                      (n + 1),               /* QP priority of the AO */
                      philoQueueSto[n],      /* event queue storage */
                      Q_DIM(philoQueueSto[n]), /* queue length [events] */
                      (void *)0,             /* stack storage (not used) */
                      0U,                    /* size of the stack [bytes] */
                      (QEvt *)0);            /* initialization event */
         }
         ~ ~ ~

 [2]     return QF_run(); /* run the QF application */
     }
@endcode


`[1]` The QS_TEST_PAUSE() macro pauses the initialization RTC after producing QS dictionaries, but before starting active objects.

`[2]` The QF_run() function completes the initialization RTC.

The following sequence diagram shows the details of pausing a test. The explanation section following the diagram clarifies the interesting points (labeled with `[xx]`):

![Pausing a test](qutest_pause.gif)


`[1]` The target reset proceeds as before and produces the ::QS_TARGET_INFO trace record.

`[2]` At some point, however, the @ref qutest_fixture "test fixture" executes <b>QS_TEST_PAUSE()</b>, which sends the ::QS_TEST_PAUSED record to the @ref qutest_script "test script". At this point, the @ref qutest_fixture "test fixture" enters the event loop, so the initialization RTC finishes and the @ref qutest_fixture "test fixture" is now responsive to commands.

`[3]` At this point, the @ref qutest_script "test script" must be explicitily expecting QS_TEST_PAUSE by means of the @ref qutest_dsl::expect_pause() "expect_pause()" command.
<br>
The best place to put @ref qutest_dsl::expect_pause() "expect_pause()" is the on_reset() callback function, which should be defined in *test scripts* corresponding to *test fixtures* that call QS_TEST_PAUSE().

`[4]` The @ref qutest_dsl::on_reset() "on_reset()" callback can now execute commands that are processed **immediately** in the @ref qutest_fixture "test fixture".

`[5]` Eventually the@ref qutest_dsl:on_reset() "on_reset()" callback releases the @ref qutest_fixture "test fixture" from the pause by executing the @ref qutest_dsl::continue_test() "continue_test()" command. This command sends ::QS_RX_TEST_CONTINUE to the @ref qutest_fixture "test fixture".

`[6]` Upon reception of ::QS_RX_TEST_CONTINUE, the @ref qutest_fixture "test fixture" continues the initialization in another RTC step.

`[7]` The @ref qutest_dsl::on_reset() "on_reset()" callback ends and the test script sends ::QS_RX_TEST_SETUP to the Target.

`[8]` The test proceeds as before.


The following @ref qutest_script "test script" code illustrates the use of the @ref qutest_dsl::expect_pause() "expect_pause()" and @ref qutest_dsl::continue_test() "continue_test()" commands:

@code
     def on_reset():
 [1]     expect_pause()
 [2]     glb_filter(GRP_SM)
         loc_filter(OBJ_SM_AO, "AO_Philo<2>")
 [3]     continue_test()
 [4]     expect("===RTC===> St-Init  Obj=AO_Philo<2>,State=QHsm_top->Philo_thinking")
         expect("===RTC===> St-Entry Obj=AO_Philo<2>,State=Philo_thinking")
         expect("@timestamp Init===> Obj=AO_Philo<2>,State=Philo_thinking")
         glb_filter(GRP_SM_AO, GRP_UA)
         current_obj(OBJ_SM_AO, "AO_Philo<2>")
     }
@endcode

@section qutest_noreset NORESET Tests
In some tests, you specifically don't want to reset the Target, but rather you want to pick up exactly where the previous test left off. For example, you wish to test a specific state of your state machine, which you reached by dispatching or posting a specific sequence of events to it in the previous tests.

For such tests, you can suppress the target reset by following the @ref qutest_dsl::test() "test()" command with the ::NORESET option. Such tests are called @ref qutest_noreset "NORESET Tests".

@note
A ::NORESET test is not allowed as the first test of a *test group* and also not after an @ref qutest_assert.


The following sequence diagram shows the details of this process. The explanation section following the diagram clarifies the interesting points (labeled with `[xx]`):

![NORESET Test](qutest_noreset.gif)


`[0]` The @ref qutest_fixture "test fixture" is done processing commands from any previous test(s) and is running an event loop.

`[1]` The @ref qutest_script "test script" executes the @ref qutest_dsl::test() "test(..., NORESET)" command.

`[2]` The @ref qutest_dsl::test() "test(..., NORESET)" command sends the ::QS_RX_TEST_SETUP command to the @ref qutest_fixture "test fixture".

`[3]` The @ref qutest_fixture "test fixture" processes ::QS_RX_TEST_SETUP immediately, because it is running the event loop.

`[4]` The @ref qutest_fixture "test fixture" responds with Trg-Ack ::QS_RX_TEST_SETUP.

`[5]`  Upon reception of Trg-Ack ::QS_RX_TEST_SETUP, the @ref qutest_script "test script" attempts to execute the @ref qutest_dsl::on_setup() "on_setup()" callback. If @ref qutest_dsl::on_setup() "on_setup()" is defined in the script, it runs at this time.
<br>
The main purpose of the @ref qutest_dsl::on_setup() "on_setup()" callback is to consume any output generated from the QS_onTestSetup() callback in the test fixture invoked in the next step [6].

`[6]` The @ref qutest_fixture "test fixture" calls the QS_onTestSetup() callback function in the Target.

`[7]` The @ref qutest_script "test script" proceeds with commands defined after the qutest_dsl::test() "test()" command. Processing of these commands is explained in sections @ref qutest_simple and @ref qutest_complex.


@section qutest_assert Assertion Tests
The use of assertions in embedded code (and especially in safety-critical code) is considered one of the **best practices** and the QP frameworks provide assertion facilities specifically designed for deeply embedded systems.

Assuming that you are using QP assertions in your code, an assertion failure can happen during a unit test. When it happens, the @ref qutest_fixture "test fixture" will produce the non-maskable ::QS_ASSERT_FAIL trace record. When this record arrives during a regular test, it will not be expected, so the test will fail. This is exactly what you want, because a failing assertion represents an error which needs to be fixed.

@note
The QP assertion handler Q_onAssert() is defined in the @ref qutest_stub "QUTest Stub". This assertion handler is instrumented to produce the ::QS_ASSERT_FAIL trace record.


However, sometimes you specifically want to test the assertion code itself, so you intentionally force an assertion in your test. In that case an assertion failure is expected and the test passes when the assertion fails. Such tests are called "Assertion Tests" and QUTest&trade; has been specifically designed to support such tests.

Here is an example of an "Assertion Test":

@code{.py}
test("TIMEOUT->Philo_thinking (ASSERT)")
probe("QActive_post_", 1)
dispatch("TIMEOUT_SIG")
expect("@timestamp Disp===> Obj=AO_Philo<2>,Sig=TIMEOUT_SIG,State=Philo_thinking")
expect("===RTC===> St-Exit  Obj=AO_Philo<2>,State=Philo_thinking")
expect("@timestamp TstProbe Fun=QActive_post_,Data=1")
expect("@timestamp =ASSERT= Mod=qf_actq,Loc=110")
@endcode

As you can see, the test ends with an explicit expectation of an assertion failure: @ref qutest_dsl::expect() "expect('@timestamp =ASSERT= Mod=qf_actq,Loc=...')". This is very easy and natural in QUTest.

@note
The only special treatment required here is that a test immediately following such an "Assertion Test" must necessarily reset the Target (it cannot be a @ref qutest_noreset "NORESET-Test").


@section qutest_qspy Categories of QSPY Output
To write effective *test scripts* you need to understand the main categories of QSPY output, which are illustrated in the picture below:

@image html  qspy_cat.png
@image latex qspy_cat.png width=5.0in
@caption{Categories of QSPY output}

`[0]` Information output generated internally by QSPY. This output is *not* sent to *test scripts*.

`[1]` Dictionary trace records generated by the Target. This output is *not* forwarded to *test scripts*.

`[2]` Acknowledgement trace records generated by the Target. This output *is* forwarded to *test scripts*, but is checked automatically and implicitly by the *test commands*.

`[3]` Trace records generated by the Target. This output *is* forwarded to *test scripts* and must be checked **explicitly** by test expectations.


@section qutest_simple Simple Commands
Simple @ref qutest_script "test script" commands do not produce any output from the Target, except for the "Trg-Ack" (acknowledgement). Examples of `<SIMPLE-COMMAND>` include @ref qutest_dsl::glb_filter() "glb_filter()", @ref qutest_dsl::loc_filter() "loc_filter()" and @ref qutest_dsl::current_obj() "current_obj()".

![Simple command processing](qutest_simple.gif)


`[1]` A @ref qutest_script "test script" sends a `<SIMPLE-COMMAND>` to the @ref qutest_fixture "test fixture".

`[2]` The @ref qutest_fixture "test fixture" receives the command and immediately starts processing it.
  </dd>

`[3]` Processing of a command triggers an RTC step and produces only the "Trg-Ack  <SIMPLE-COMMAND>" (acknowledgement of the specific `<SIMPLE-COMMAND>`).

`[4]` Immediately after sending the `<SIMPLE-COMMAND>`, the @ref qutest_script "test script" enters an implicit expect state, in which it waits for the "Trg-Ack <SIMPLE-COMMAND>" output from the Target. The processing of the `<SIMPLE-COMMAND>` ends when the next output received from the Target exactly matches the expected output.


@section qutest_complex Complex Commands
Complex @ref qutest_script "test script" commands might produce some output from the Target, not just the "Trg-Ack" (acknowledgement). Examples of `<COMPLEX-COMMAND>` include @ref qutest_dsl::command() "command()", @ref qutest_dsl::dispatch() "dispatch()", @ref qutest_dsl::post() "post()" and @ref qutest_dsl::tick() "tick()".

![Complex command processing](qutest_complex.gif)


`[1]` A @ref qutest_script "test script" sends a `<COMPLEX-COMMAND>` to the @ref qutest_fixture "test fixture".

`[2]` The @ref qutest_fixture "test fixture" receives the command and immediately starts processing it.

`[3]` Processing of a command triggers an RTC step and produces only the "Trg-Ack  <COMPLEX-COMMAND>" (acknowledgement of the specific `<COMPLEX-COMMAND>`).

`[4]` The `<COMPLEX-COMMAND>` must be followed in the @ref qutest_script "test script" by the explicit expect() commands that consume any output produced by the command.

`[5-6]` The @ref qutest_fixture "test fixture" produces some output.

`[7]` Each such ouput is consumed by the matching expect() command.

`[8]` The @ref qutest_fixture "test fixture" sends the additional QS record "Trg-Done <COMPLEX-COMMAND>", which explicitly delimits the output from this particular command.

`[9]` The @ref qutest_script "test script" must consume the "Trg-Done <COMPLEX-COMMAND>" record by an explicit expect() command.
  </dd>

@nav{qutest_use,qutest_tut}
*/
